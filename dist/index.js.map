{
  "version": 3,
  "sources": ["../node_modules/@trpc/server/dist/TRPCError-226f5343.mjs", "../node_modules/@trpc/server/dist/codes-52c11119.mjs", "../node_modules/@trpc/server/dist/index-972002da.mjs", "../node_modules/@trpc/server/dist/config-6e96a9bc.mjs", "../node_modules/@trpc/server/dist/transformTRPCResponse-7a73a2df.mjs", "../node_modules/@trpc/server/dist/resolveHTTPResponse-edf72fc7.mjs", "../node_modules/@trpc/server/dist/adapters/fetch/index.mjs", "../node_modules/@trpc/server/dist/index.mjs", "../server/index.ts"],
  "sourcesContent": ["function getMessageFromUnknownError(err, fallback) {\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (err instanceof Error && typeof err.message === 'string') {\n        return err.message;\n    }\n    return fallback;\n}\nfunction getErrorFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const message = getMessageFromUnknownError(cause, 'Unknown error');\n    return new Error(message);\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    return undefined;\n}\n\nfunction getTRPCErrorFromUnknown(cause) {\n    const error = getErrorFromUnknown(cause);\n    if (error instanceof TRPCError) {\n        return error;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause: error,\n        message: error.message\n    });\n    // Inherit stack from error\n    trpcError.stack = error.stack;\n    return trpcError;\n}\nclass TRPCError extends Error {\n    constructor(opts){\n        const message = opts.message ?? getMessageFromUnknownError(opts.cause, opts.code);\n        const cause = opts.cause !== undefined ? getErrorFromUnknown(opts.cause) : undefined;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.code = opts.code;\n        this.name = this.constructor.name;\n    }\n}\n\nexport { TRPCError as T, getTRPCErrorFromUnknown as a, getCauseFromUnknown as g };\n", "function invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    /**\n   * Internal JSON-RPC error.\n   */ INTERNAL_SERVER_ERROR: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\n\nexport { TRPC_ERROR_CODES_BY_KEY as T, TRPC_ERROR_CODES_BY_NUMBER as a, invert as i };\n", "const noop = ()=>{\n// noop\n};\nfunction createInnerProxy(callback, path) {\n    const proxy = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ]);\n        },\n        apply (_1, _2, args) {\n            return callback({\n                args,\n                path\n            });\n        }\n    });\n    return proxy;\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, []);\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (typeof name !== 'string' || name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { createRecursiveProxy as a, createFlatProxy as c };\n", "import { T as TRPCError } from './TRPCError-226f5343.mjs';\nimport { i as invert, T as TRPC_ERROR_CODES_BY_KEY } from './codes-52c11119.mjs';\nimport { a as createRecursiveProxy } from './index-972002da.mjs';\n\n/**\n * @public\n */ /**\n * @internal\n */ function getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n * @internal\n */ const defaultTransformer = {\n    _default: true,\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\n\nconst defaultFormatter = ({ shape  })=>{\n    return shape;\n};\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    CLIENT_CLOSED_REQUEST: 499,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    METHOD_NOT_SUPPORTED: 405,\n    TOO_MANY_REQUESTS: 429\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    const { code  } = error;\n    return getStatusCodeFromKey(code);\n}\n\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\n\nconst procedureTypes = [\n    'query',\n    'mutation',\n    'subscription'\n];\n\nfunction isRouter(procedureOrRouter) {\n    return 'router' in procedureOrRouter._def;\n}\nfunction isNestedRouter(procedureOrRouter) {\n    return !('_def' in procedureOrRouter);\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n * Reserved words that can't be used as router or procedure names\n */ const reservedWords = [\n    /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */ 'then',\n    /**\n   * `_def` is a reserved word because it's used internally a lot\n   */ '_def'\n];\n/**\n * @internal\n */ function createRouterFactory(config) {\n    return function createRouterInner(procedures) {\n        const reservedWordsUsed = new Set(Object.keys(procedures).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) {\n            throw new Error('Reserved words used in `router({})` call: ' + Array.from(reservedWordsUsed).join(', '));\n        }\n        const newProcedures = {};\n        for (const [key, procedureOrRouter] of Object.entries(procedures ?? {})){\n            const value = procedures[key] ?? {};\n            if (isNestedRouter(value)) {\n                newProcedures[key] = createRouterInner(value);\n                continue;\n            }\n            if (isRouter(value)) {\n                newProcedures[key] = procedureOrRouter;\n                continue;\n            }\n            newProcedures[key] = procedureOrRouter;\n        }\n        const routerProcedures = omitPrototype({});\n        function recursiveGetPaths(procedures, path = '') {\n            for (const [key, procedureOrRouter] of Object.entries(procedures ?? {})){\n                const newPath = `${path}${key}`;\n                if (isNestedRouter(procedureOrRouter)) {\n                    recursiveGetPaths(procedureOrRouter, `${newPath}.`);\n                    continue;\n                }\n                if (isRouter(procedureOrRouter)) {\n                    recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);\n                    continue;\n                }\n                if (routerProcedures[newPath]) {\n                    throw new Error(`Duplicate key: ${newPath}`);\n                }\n                routerProcedures[newPath] = procedureOrRouter;\n            }\n        }\n        recursiveGetPaths(newProcedures);\n        const _def = {\n            _config: config,\n            router: true,\n            procedures: routerProcedures,\n            ...emptyRouter,\n            record: newProcedures,\n            queries: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.query).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {}),\n            mutations: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.mutation).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {}),\n            subscriptions: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.subscription).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {})\n        };\n        const router = {\n            ...newProcedures,\n            _def,\n            createCaller (ctx) {\n                const proxy = createRecursiveProxy(({ path , args  })=>{\n                    // interop mode\n                    if (path.length === 1 && procedureTypes.includes(path[0])) {\n                        return callProcedure({\n                            procedures: _def.procedures,\n                            path: args[0],\n                            rawInput: args[1],\n                            ctx,\n                            type: path[0]\n                        });\n                    }\n                    const fullPath = path.join('.');\n                    const procedure = _def.procedures[fullPath];\n                    let type = 'query';\n                    if (procedure._def.mutation) {\n                        type = 'mutation';\n                    } else if (procedure._def.subscription) {\n                        type = 'subscription';\n                    }\n                    return procedure({\n                        path: fullPath,\n                        rawInput: args[0],\n                        ctx,\n                        type\n                    });\n                });\n                return proxy;\n            },\n            getErrorShape (opts) {\n                const { path , error  } = opts;\n                const { code  } = opts.error;\n                const shape = {\n                    message: error.message,\n                    code: TRPC_ERROR_CODES_BY_KEY[code],\n                    data: {\n                        code,\n                        httpStatus: getHTTPStatusCodeFromError(error)\n                    }\n                };\n                if (config.isDev && typeof opts.error.stack === 'string') {\n                    shape.data.stack = opts.error.stack;\n                }\n                if (typeof path === 'string') {\n                    shape.data.path = path;\n                }\n                return this._def._config.errorFormatter({\n                    ...opts,\n                    shape\n                });\n            }\n        };\n        return router;\n    };\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type , path  } = opts;\n    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    const procedure = opts.procedures[path];\n    return procedure(opts);\n}\n\n/**\n * The default check to see if we're in a server\n */ const isServerDefault = typeof window === 'undefined' || 'Deno' in window || globalThis.process?.env?.NODE_ENV === 'test' || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;\n\nexport { TRPC_ERROR_CODES_BY_NUMBER as T, defaultTransformer as a, getDataTransformer as b, createRouterFactory as c, defaultFormatter as d, callProcedure as e, getHTTPStatusCode as f, getHTTPStatusCodeFromError as g, isServerDefault as i, procedureTypes as p };\n", "function transformTRPCResponseItem(router, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: router._def._config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: router._def._config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(router, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(router, item)) : transformTRPCResponseItem(router, itemOrItems);\n}\n\nexport { transformTRPCResponse as t };\n", "import { e as callProcedure, f as getHTTPStatusCode } from './config-6e96a9bc.mjs';\nimport { T as TRPCError, a as getTRPCErrorFromUnknown, g as getCauseFromUnknown } from './TRPCError-226f5343.mjs';\nimport { t as transformTRPCResponse } from './transformTRPCResponse-7a73a2df.mjs';\n\nconst HTTP_METHOD_PROCEDURE_TYPE_MAP = {\n    GET: 'query',\n    POST: 'mutation'\n};\nfunction getRawProcedureInputOrThrow(req) {\n    try {\n        if (req.method === 'GET') {\n            if (!req.query.has('input')) {\n                return undefined;\n            }\n            const raw = req.query.get('input');\n            return JSON.parse(raw);\n        }\n        if (typeof req.body === 'string') {\n            // A mutation with no inputs will have req.body === ''\n            return req.body.length === 0 ? undefined : JSON.parse(req.body);\n        }\n        return req.body;\n    } catch (err) {\n        throw new TRPCError({\n            code: 'PARSE_ERROR',\n            cause: getCauseFromUnknown(err)\n        });\n    }\n}\nasync function resolveHTTPResponse(opts) {\n    const { createContext , onError , router , req  } = opts;\n    const batchingEnabled = opts.batching?.enabled ?? true;\n    if (req.method === 'HEAD') {\n        // can be used for lambda warmup\n        return {\n            status: 204\n        };\n    }\n    const type = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method] ?? 'unknown';\n    let ctx = undefined;\n    let paths = undefined;\n    const isBatchCall = !!req.query.get('batch');\n    function endResponse(untransformedJSON, errors) {\n        let status = getHTTPStatusCode(untransformedJSON);\n        const headers = {\n            'Content-Type': 'application/json'\n        };\n        const meta = opts.responseMeta?.({\n            ctx,\n            paths,\n            type,\n            data: Array.isArray(untransformedJSON) ? untransformedJSON : [\n                untransformedJSON\n            ],\n            errors\n        }) ?? {};\n        for (const [key, value] of Object.entries(meta.headers ?? {})){\n            headers[key] = value;\n        }\n        if (meta.status) {\n            status = meta.status;\n        }\n        const transformedJSON = transformTRPCResponse(router, untransformedJSON);\n        const body = JSON.stringify(transformedJSON);\n        return {\n            body,\n            status,\n            headers\n        };\n    }\n    try {\n        if (opts.error) {\n            throw opts.error;\n        }\n        if (isBatchCall && !batchingEnabled) {\n            throw new Error(`Batching is not enabled on the server`);\n        }\n        /* istanbul ignore if -- @preserve */ if (type === 'subscription') {\n            throw new TRPCError({\n                message: 'Subscriptions should use wsLink',\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        if (type === 'unknown') {\n            throw new TRPCError({\n                message: `Unexpected request method ${req.method}`,\n                code: 'METHOD_NOT_SUPPORTED'\n            });\n        }\n        const rawInput = getRawProcedureInputOrThrow(req);\n        paths = isBatchCall ? opts.path.split(',') : [\n            opts.path\n        ];\n        ctx = await createContext();\n        const deserializeInputValue = (rawValue)=>{\n            return typeof rawValue !== 'undefined' ? router._def._config.transformer.input.deserialize(rawValue) : rawValue;\n        };\n        const getInputs = ()=>{\n            if (!isBatchCall) {\n                return {\n                    0: deserializeInputValue(rawInput)\n                };\n            }\n            /* istanbul ignore if -- @preserve */ if (rawInput == null || typeof rawInput !== 'object' || Array.isArray(rawInput)) {\n                throw new TRPCError({\n                    code: 'BAD_REQUEST',\n                    message: '\"input\" needs to be an object when doing a batch call'\n                });\n            }\n            const input = {};\n            for(const key in rawInput){\n                const k = key;\n                const rawValue = rawInput[k];\n                const value = deserializeInputValue(rawValue);\n                input[k] = value;\n            }\n            return input;\n        };\n        const inputs = getInputs();\n        const rawResults = await Promise.all(paths.map(async (path, index)=>{\n            const input = inputs[index];\n            try {\n                const output = await callProcedure({\n                    procedures: router._def.procedures,\n                    path,\n                    rawInput: input,\n                    ctx,\n                    type\n                });\n                return {\n                    input,\n                    path,\n                    data: output\n                };\n            } catch (cause) {\n                const error = getTRPCErrorFromUnknown(cause);\n                onError?.({\n                    error,\n                    path,\n                    input,\n                    ctx,\n                    type: type,\n                    req\n                });\n                return {\n                    input,\n                    path,\n                    error\n                };\n            }\n        }));\n        const errors = rawResults.flatMap((obj)=>obj.error ? [\n                obj.error\n            ] : []);\n        const resultEnvelopes = rawResults.map((obj)=>{\n            const { path , input  } = obj;\n            if (obj.error) {\n                return {\n                    error: router.getErrorShape({\n                        error: obj.error,\n                        type,\n                        path,\n                        input,\n                        ctx\n                    })\n                };\n            } else {\n                return {\n                    result: {\n                        data: obj.data\n                    }\n                };\n            }\n        });\n        const result = isBatchCall ? resultEnvelopes : resultEnvelopes[0];\n        return endResponse(result, errors);\n    } catch (cause) {\n        // we get here if\n        // - batching is called when it's not enabled\n        // - `createContext()` throws\n        // - post body is too large\n        // - input deserialization fails\n        // - `errorFormatter` return value is malformed\n        const error = getTRPCErrorFromUnknown(cause);\n        onError?.({\n            error,\n            path: undefined,\n            input: undefined,\n            ctx,\n            type: type,\n            req\n        });\n        return endResponse({\n            error: router.getErrorShape({\n                error,\n                type,\n                path: undefined,\n                input: undefined,\n                ctx\n            })\n        }, [\n            error\n        ]);\n    }\n}\n\nexport { resolveHTTPResponse as r };\n", "import { r as resolveHTTPResponse } from '../../resolveHTTPResponse-edf72fc7.mjs';\nimport '../../config-6e96a9bc.mjs';\nimport '../../TRPCError-226f5343.mjs';\nimport '../../codes-52c11119.mjs';\nimport '../../index-972002da.mjs';\nimport '../../transformTRPCResponse-7a73a2df.mjs';\n\nasync function fetchRequestHandler(opts) {\n    const resHeaders = new Headers();\n    const createContext = async ()=>{\n        return opts.createContext?.({\n            req: opts.req,\n            resHeaders\n        });\n    };\n    const url = new URL(opts.req.url);\n    const path = url.pathname.slice(opts.endpoint.length + 1);\n    const req = {\n        query: url.searchParams,\n        method: opts.req.method,\n        headers: Object.fromEntries(opts.req.headers),\n        body: await opts.req.text()\n    };\n    const result = await resolveHTTPResponse({\n        req,\n        createContext,\n        path,\n        router: opts.router,\n        batching: opts.batching,\n        responseMeta: opts.responseMeta,\n        onError (o) {\n            opts?.onError?.({\n                ...o,\n                req: opts.req\n            });\n        }\n    });\n    for (const [key, value] of Object.entries(result.headers ?? {})){\n        /* istanbul ignore if -- @preserve */ if (typeof value === 'undefined') {\n            continue;\n        }\n        if (typeof value === 'string') {\n            resHeaders.set(key, value);\n            continue;\n        }\n        for (const v of value){\n            resHeaders.append(key, v);\n        }\n    }\n    const res = new Response(result.body, {\n        status: result.status,\n        headers: resHeaders\n    });\n    return res;\n}\n\nexport { fetchRequestHandler };\n", "import { c as createRouterFactory, d as defaultFormatter, g as getHTTPStatusCodeFromError, a as defaultTransformer, b as getDataTransformer$1, i as isServerDefault } from './config-6e96a9bc.mjs';\nexport { e as callProcedure, a as defaultTransformer, b as getDataTransformer, p as procedureTypes } from './config-6e96a9bc.mjs';\nimport { T as TRPCError, g as getCauseFromUnknown, a as getTRPCErrorFromUnknown } from './TRPCError-226f5343.mjs';\nexport { T as TRPCError, a as getTRPCErrorFromUnknown } from './TRPCError-226f5343.mjs';\nimport { T as TRPC_ERROR_CODES_BY_KEY } from './codes-52c11119.mjs';\nimport { c as createFlatProxy } from './index-972002da.mjs';\n\n/**\n * @deprecated\n */ const middlewareMarker$1 = 'middlewareMarker';\n\nfunction getParseFn$1(procedureParser) {\n    const parser = procedureParser;\n    if (typeof parser === 'function') {\n        // ProcedureParserCustomValidatorEsque\n        return parser;\n    }\n    if (typeof parser.parseAsync === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parseAsync.bind(parser);\n    }\n    if (typeof parser.parse === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parse.bind(parser);\n    }\n    if (typeof parser.validateSync === 'function') {\n        // ProcedureParserYupEsque\n        return parser.validateSync.bind(parser);\n    }\n    if (typeof parser.create === 'function') {\n        // ProcedureParserSuperstructEsque\n        return parser.create.bind(parser);\n    }\n    throw new Error('Could not find a validator fn');\n}\n/**\n * @internal\n * @deprecated\n */ class Procedure {\n    _def() {\n        return {\n            middlewares: this.middlewares,\n            resolver: this.resolver,\n            inputParser: this.inputParser,\n            outputParser: this.outputParser,\n            meta: this.meta\n        };\n    }\n    async parseInput(rawInput) {\n        try {\n            return await this.parseInputFn(rawInput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                cause: getCauseFromUnknown(cause)\n            });\n        }\n    }\n    async parseOutput(rawOutput) {\n        try {\n            return await this.parseOutputFn(rawOutput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                cause: getCauseFromUnknown(cause),\n                message: 'Output validation failed'\n            });\n        }\n    }\n    /**\n   * Trigger middlewares in order, parse raw input, call resolver & parse raw output\n   * @internal\n   */ async call(opts) {\n        // wrap the actual resolver and treat as the last \"middleware\"\n        const middlewaresWithResolver = this.middlewares.concat([\n            async ({ ctx  })=>{\n                const input = await this.parseInput(opts.rawInput);\n                const rawOutput = await this.resolver({\n                    ...opts,\n                    ctx,\n                    input\n                });\n                const data = await this.parseOutput(rawOutput);\n                return {\n                    marker: middlewareMarker$1,\n                    ok: true,\n                    data,\n                    ctx\n                };\n            }\n        ]);\n        // run the middlewares recursively with the resolver as the last one\n        const callRecursive = async (callOpts = {\n            index: 0,\n            ctx: opts.ctx\n        })=>{\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const result = await middlewaresWithResolver[callOpts.index]({\n                    ctx: callOpts.ctx,\n                    type: opts.type,\n                    path: opts.path,\n                    rawInput: opts.rawInput,\n                    meta: this.meta,\n                    next: async (nextOpts)=>{\n                        return await callRecursive({\n                            index: callOpts.index + 1,\n                            ctx: nextOpts ? nextOpts.ctx : callOpts.ctx\n                        });\n                    }\n                });\n                return result;\n            } catch (cause) {\n                return {\n                    ctx: callOpts.ctx,\n                    ok: false,\n                    error: getTRPCErrorFromUnknown(cause),\n                    marker: middlewareMarker$1\n                };\n            }\n        };\n        // there's always at least one \"next\" since we wrap this.resolver in a middleware\n        const result = await callRecursive();\n        if (!result) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                message: 'No result from middlewares - did you forget to `return next()`?'\n            });\n        }\n        if (!result.ok) {\n            // re-throw original error\n            throw result.error;\n        }\n        return result.data;\n    }\n    /**\n   * Create new procedure with passed middlewares\n   * @param middlewares\n   */ inheritMiddlewares(middlewares) {\n        const Constructor = this.constructor;\n        const instance = new Constructor({\n            middlewares: [\n                ...middlewares,\n                ...this.middlewares\n            ],\n            resolver: this.resolver,\n            inputParser: this.inputParser,\n            outputParser: this.outputParser,\n            meta: this.meta\n        });\n        return instance;\n    }\n    constructor(opts){\n        this.middlewares = opts.middlewares;\n        this.resolver = opts.resolver;\n        this.inputParser = opts.inputParser;\n        this.parseInputFn = getParseFn$1(this.inputParser);\n        this.outputParser = opts.outputParser;\n        this.parseOutputFn = getParseFn$1(this.outputParser);\n        this.meta = opts.meta;\n    }\n}\nfunction createProcedure(opts) {\n    const inputParser = 'input' in opts ? opts.input : (input)=>{\n        if (input != null) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                message: 'No input expected'\n            });\n        }\n        return undefined;\n    };\n    const outputParser = 'output' in opts && opts.output ? opts.output : (output)=>output;\n    return new Procedure({\n        inputParser: inputParser,\n        resolver: opts.resolve,\n        middlewares: [],\n        outputParser: outputParser,\n        meta: opts.meta\n    });\n}\n\nfunction getParseFn(procedureParser) {\n    const parser = procedureParser;\n    if (typeof parser === 'function') {\n        // ProcedureParserCustomValidatorEsque\n        return parser;\n    }\n    if (typeof parser.parseAsync === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parseAsync.bind(parser);\n    }\n    if (typeof parser.parse === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parse.bind(parser);\n    }\n    if (typeof parser.validateSync === 'function') {\n        // ProcedureParserYupEsque\n        return parser.validateSync.bind(parser);\n    }\n    if (typeof parser.create === 'function') {\n        // ProcedureParserSuperstructEsque\n        return parser.create.bind(parser);\n    }\n    if (typeof parser.assert === 'function') {\n        // ParserScaleEsque\n        return (value)=>{\n            parser.assert(value);\n            return value;\n        };\n    }\n    throw new Error('Could not find a validator fn');\n}\n/**\n * @deprecated only for backwards compat\n * @internal\n */ function getParseFnOrPassThrough(procedureParser) {\n    if (!procedureParser) {\n        return (v)=>v;\n    }\n    return getParseFn(procedureParser);\n}\n\n/**\n * Ensures there are no duplicate keys when building a procedure.\n */ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs){\n        for(const key in overrides){\n            if (key in newObj && newObj[key] !== overrides[key]) {\n                throw new Error(`Duplicate key ${key}`);\n            }\n            newObj[key] = overrides[key];\n        }\n    }\n    return newObj;\n}\n\n/**\n * @internal\n */ function createMiddlewareFactory() {\n    function createMiddlewareInner(middlewares) {\n        return {\n            _middlewares: middlewares,\n            unstable_pipe (middlewareBuilderOrFn) {\n                const pipedMiddleware = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                    middlewareBuilderOrFn\n                ];\n                return createMiddlewareInner([\n                    ...middlewares,\n                    ...pipedMiddleware\n                ]);\n            }\n        };\n    }\n    function createMiddleware(fn) {\n        return createMiddlewareInner([\n            fn\n        ]);\n    }\n    return createMiddleware;\n}\nfunction isPlainObject(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n}\n/**\n * @internal\n * Please note, `trpc-openapi` uses this function.\n */ function createInputMiddleware(parse) {\n    const inputMiddleware = async ({ next , rawInput , input  })=>{\n        let parsedInput;\n        try {\n            parsedInput = await parse(rawInput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                cause: getCauseFromUnknown(cause)\n            });\n        }\n        // Multiple input parsers\n        const combinedInput = isPlainObject(input) && isPlainObject(parsedInput) ? {\n            ...input,\n            ...parsedInput\n        } : parsedInput;\n        // TODO fix this typing?\n        return next({\n            input: combinedInput\n        });\n    };\n    inputMiddleware._type = 'input';\n    return inputMiddleware;\n}\n/**\n * @internal\n */ function createOutputMiddleware(parse) {\n    const outputMiddleware = async ({ next  })=>{\n        const result = await next();\n        if (!result.ok) {\n            // pass through failures without validating\n            return result;\n        }\n        try {\n            const data = await parse(result.data);\n            return {\n                ...result,\n                data\n            };\n        } catch (cause) {\n            throw new TRPCError({\n                message: 'Output validation failed',\n                code: 'INTERNAL_SERVER_ERROR',\n                cause: getCauseFromUnknown(cause)\n            });\n        }\n    };\n    outputMiddleware._type = 'output';\n    return outputMiddleware;\n}\n\n/**\n * @internal\n */ const middlewareMarker = 'middlewareMarker';\n\nfunction createNewBuilder(def1, def2) {\n    const { middlewares =[] , inputs , meta , ...rest } = def2;\n    // TODO: maybe have a fn here to warn about calls\n    return createBuilder({\n        ...mergeWithoutOverrides(def1, rest),\n        inputs: [\n            ...def1.inputs,\n            ...inputs ?? []\n        ],\n        middlewares: [\n            ...def1.middlewares,\n            ...middlewares\n        ],\n        meta: def1.meta && meta ? {\n            ...def1.meta,\n            ...meta\n        } : meta ?? def1.meta\n    });\n}\nfunction createBuilder(initDef = {}) {\n    const _def = {\n        inputs: [],\n        middlewares: [],\n        ...initDef\n    };\n    return {\n        _def,\n        input (input) {\n            const parser = getParseFn(input);\n            return createNewBuilder(_def, {\n                inputs: [\n                    input\n                ],\n                middlewares: [\n                    createInputMiddleware(parser)\n                ]\n            });\n        },\n        output (output) {\n            const parseOutput = getParseFn(output);\n            return createNewBuilder(_def, {\n                output,\n                middlewares: [\n                    createOutputMiddleware(parseOutput)\n                ]\n            });\n        },\n        meta (meta) {\n            return createNewBuilder(_def, {\n                meta: meta\n            });\n        },\n        /**\n     * @deprecated\n     * This functionality is deprecated and will be removed in the next major version.\n     */ unstable_concat (builder) {\n            return createNewBuilder(_def, builder._def);\n        },\n        use (middlewareBuilderOrFn) {\n            // Distinguish between a middleware builder and a middleware function\n            const middlewares = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                middlewareBuilderOrFn\n            ];\n            return createNewBuilder(_def, {\n                middlewares\n            });\n        },\n        query (resolver) {\n            return createResolver({\n                ..._def,\n                query: true\n            }, resolver);\n        },\n        mutation (resolver) {\n            return createResolver({\n                ..._def,\n                mutation: true\n            }, resolver);\n        },\n        subscription (resolver) {\n            return createResolver({\n                ..._def,\n                subscription: true\n            }, resolver);\n        }\n    };\n}\nfunction createResolver(_def, resolver) {\n    const finalBuilder = createNewBuilder(_def, {\n        resolver,\n        middlewares: [\n            async function resolveMiddleware(opts) {\n                const data = await resolver(opts);\n                return {\n                    marker: middlewareMarker,\n                    ok: true,\n                    data,\n                    ctx: opts.ctx\n                };\n            }\n        ]\n    });\n    return createProcedureCaller(finalBuilder._def);\n}\nconst codeblock = `\nIf you want to call this function on the server, you do the following:\nThis is a client-only function.\n\nconst caller = appRouter.createCaller({\n  /* ... your context */\n});\n\nconst result = await caller.call('myProcedure', input);\n`.trim();\nfunction createProcedureCaller(_def) {\n    const procedure = async function resolve(opts) {\n        // is direct server-side call\n        if (!opts || !('rawInput' in opts)) {\n            throw new Error(codeblock);\n        }\n        // run the middlewares recursively with the resolver as the last one\n        const callRecursive = async (callOpts = {\n            index: 0,\n            ctx: opts.ctx\n        })=>{\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const middleware = _def.middlewares[callOpts.index];\n                const result = await middleware({\n                    ctx: callOpts.ctx,\n                    type: opts.type,\n                    path: opts.path,\n                    rawInput: opts.rawInput,\n                    meta: _def.meta,\n                    input: callOpts.input,\n                    next: async (nextOpts)=>{\n                        return await callRecursive({\n                            index: callOpts.index + 1,\n                            ctx: nextOpts && 'ctx' in nextOpts ? {\n                                ...callOpts.ctx,\n                                ...nextOpts.ctx\n                            } : callOpts.ctx,\n                            input: nextOpts && 'input' in nextOpts ? nextOpts.input : callOpts.input\n                        });\n                    }\n                });\n                return result;\n            } catch (cause) {\n                return {\n                    ok: false,\n                    error: getTRPCErrorFromUnknown(cause),\n                    marker: middlewareMarker\n                };\n            }\n        };\n        // there's always at least one \"next\" since we wrap this.resolver in a middleware\n        const result = await callRecursive();\n        if (!result) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                message: 'No result from middlewares - did you forget to `return next()`?'\n            });\n        }\n        if (!result.ok) {\n            // re-throw original error\n            throw result.error;\n        }\n        return result.data;\n    };\n    procedure._def = _def;\n    procedure.meta = _def.meta;\n    return procedure;\n}\n\nfunction migrateProcedure(oldProc, type) {\n    const def = oldProc._def();\n    const inputParser = getParseFnOrPassThrough(def.inputParser);\n    const outputParser = getParseFnOrPassThrough(def.outputParser);\n    const inputMiddleware = createInputMiddleware(inputParser);\n    const builder = createBuilder({\n        inputs: [\n            def.inputParser\n        ],\n        middlewares: [\n            ...def.middlewares,\n            inputMiddleware,\n            createOutputMiddleware(outputParser)\n        ],\n        meta: def.meta,\n        output: def.outputParser,\n        mutation: type === 'mutation',\n        query: type === 'query',\n        subscription: type === 'subscription'\n    });\n    const proc = builder[type]((opts)=>def.resolver(opts));\n    return proc;\n}\nfunction migrateRouter(oldRouter) {\n    const errorFormatter = oldRouter._def.errorFormatter;\n    const transformer = oldRouter._def.transformer;\n    const queries = {};\n    const mutations = {};\n    const subscriptions = {};\n    for (const [name, procedure] of Object.entries(oldRouter._def.queries)){\n        queries[name] = migrateProcedure(procedure, 'query');\n    }\n    for (const [name1, procedure1] of Object.entries(oldRouter._def.mutations)){\n        mutations[name1] = migrateProcedure(procedure1, 'mutation');\n    }\n    for (const [name2, procedure2] of Object.entries(oldRouter._def.subscriptions)){\n        subscriptions[name2] = migrateProcedure(procedure2, 'subscription');\n    }\n    const procedures = mergeWithoutOverrides(queries, mutations, subscriptions);\n    const newRouter = createRouterFactory({\n        transformer,\n        errorFormatter,\n        isDev: process.env.NODE_ENV !== 'production'\n    })(procedures);\n    return newRouter;\n}\n\nfunction getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\nconst PROCEDURE_DEFINITION_MAP = {\n    query: 'queries',\n    mutation: 'mutations',\n    subscription: 'subscriptions'\n};\nfunction safeObject(...args) {\n    return Object.assign(Object.create(null), ...args);\n}\n/**\n * @internal The type signature of this class may change without warning.\n * @deprecated\n */ class Router {\n    static prefixProcedures(procedures, prefix) {\n        const eps = safeObject();\n        for (const [key, procedure] of Object.entries(procedures)){\n            eps[prefix + key] = procedure;\n        }\n        return eps;\n    }\n    query(path, procedure) {\n        const router = new Router({\n            queries: safeObject({\n                [path]: createProcedure(procedure)\n            })\n        });\n        return this.merge(router);\n    }\n    mutation(path, procedure) {\n        const router = new Router({\n            mutations: safeObject({\n                [path]: createProcedure(procedure)\n            })\n        });\n        return this.merge(router);\n    }\n    subscription(path, procedure) {\n        const router = new Router({\n            subscriptions: safeObject({\n                [path]: createProcedure(procedure)\n            })\n        });\n        return this.merge(router);\n    }\n    merge(prefixOrRouter, maybeRouter) {\n        let prefix = '';\n        let childRouter;\n        if (typeof prefixOrRouter === 'string' && maybeRouter instanceof Router) {\n            prefix = prefixOrRouter;\n            childRouter = maybeRouter;\n        } else if (prefixOrRouter instanceof Router) {\n            childRouter = prefixOrRouter;\n        } else {\n            throw new Error('Invalid args');\n        }\n        const duplicateQueries = Object.keys(childRouter._def.queries).filter((key)=>!!this._def['queries'][prefix + key]);\n        const duplicateMutations = Object.keys(childRouter._def.mutations).filter((key)=>!!this._def['mutations'][prefix + key]);\n        const duplicateSubscriptions = Object.keys(childRouter._def.subscriptions).filter((key)=>!!this._def['subscriptions'][prefix + key]);\n        const duplicates = [\n            ...duplicateQueries,\n            ...duplicateMutations,\n            ...duplicateSubscriptions\n        ];\n        if (duplicates.length) {\n            throw new Error(`Duplicate endpoint(s): ${duplicates.join(', ')}`);\n        }\n        const mergeProcedures = (defs)=>{\n            const newDefs = safeObject();\n            for (const [key, procedure] of Object.entries(defs)){\n                const newProcedure = procedure.inheritMiddlewares(this._def.middlewares);\n                newDefs[key] = newProcedure;\n            }\n            return Router.prefixProcedures(newDefs, prefix);\n        };\n        return new Router({\n            ...this._def,\n            queries: safeObject(this._def.queries, mergeProcedures(childRouter._def.queries)),\n            mutations: safeObject(this._def.mutations, mergeProcedures(childRouter._def.mutations)),\n            subscriptions: safeObject(this._def.subscriptions, mergeProcedures(childRouter._def.subscriptions))\n        });\n    }\n    /**\n   * Invoke procedure. Only for internal use within library.\n   */ async call(opts) {\n        const { type , path  } = opts;\n        const defTarget = PROCEDURE_DEFINITION_MAP[type];\n        const defs = this._def[defTarget];\n        const procedure = defs[path];\n        if (!procedure) {\n            throw new TRPCError({\n                code: 'NOT_FOUND',\n                message: `No \"${type}\"-procedure on path \"${path}\"`\n            });\n        }\n        return procedure.call(opts);\n    }\n    createCaller(ctx) {\n        return {\n            query: (path, ...args)=>{\n                return this.call({\n                    type: 'query',\n                    ctx,\n                    path,\n                    rawInput: args[0]\n                });\n            },\n            mutation: (path, ...args)=>{\n                return this.call({\n                    type: 'mutation',\n                    ctx,\n                    path,\n                    rawInput: args[0]\n                });\n            },\n            subscription: (path, ...args)=>{\n                return this.call({\n                    type: 'subscription',\n                    ctx,\n                    path,\n                    rawInput: args[0]\n                });\n            }\n        };\n    }\n    /**\n   * Function to be called before any procedure is invoked\n   * @link https://trpc.io/docs/middlewares\n   */ middleware(middleware) {\n        return new Router({\n            ...this._def,\n            middlewares: [\n                ...this._def.middlewares,\n                middleware\n            ]\n        });\n    }\n    /**\n   * Format errors\n   * @link https://trpc.io/docs/error-formatting\n   */ formatError(errorFormatter) {\n        if (this._def.errorFormatter !== defaultFormatter) {\n            throw new Error('You seem to have double `formatError()`-calls in your router tree');\n        }\n        return new Router({\n            ...this._def,\n            errorFormatter: errorFormatter\n        });\n    }\n    getErrorShape(opts) {\n        const { path , error  } = opts;\n        const { code  } = opts.error;\n        const shape = {\n            message: error.message,\n            code: TRPC_ERROR_CODES_BY_KEY[code],\n            data: {\n                code,\n                httpStatus: getHTTPStatusCodeFromError(error)\n            }\n        };\n        if (globalThis.process?.env?.NODE_ENV !== 'production' && typeof opts.error.stack === 'string') {\n            shape.data.stack = opts.error.stack;\n        }\n        if (typeof path === 'string') {\n            shape.data.path = path;\n        }\n        return this._def.errorFormatter({\n            ...opts,\n            shape\n        });\n    }\n    /**\n   * Add data transformer to serialize/deserialize input args + output\n   * @link https://trpc.io/docs/data-transformers\n   */ transformer(_transformer) {\n        const transformer = getDataTransformer(_transformer);\n        if (this._def.transformer !== defaultTransformer) {\n            throw new Error('You seem to have double `transformer()`-calls in your router tree');\n        }\n        return new Router({\n            ...this._def,\n            transformer\n        });\n    }\n    /**\n   * Flattens the generics of TQueries/TMutations/TSubscriptions.\n   * \u26A0\uFE0F Experimental - might disappear. \u26A0\uFE0F\n   *\n   * @alpha\n   */ flat() {\n        return this;\n    }\n    /**\n   * Interop mode for v9.x -> v10.x\n   */ interop() {\n        return migrateRouter(this);\n    }\n    constructor(def){\n        this._def = {\n            queries: def?.queries ?? safeObject(),\n            mutations: def?.mutations ?? safeObject(),\n            subscriptions: def?.subscriptions ?? safeObject(),\n            middlewares: def?.middlewares ?? [],\n            errorFormatter: def?.errorFormatter ?? defaultFormatter,\n            transformer: def?.transformer ?? defaultTransformer\n        };\n    }\n}\n/**\n * @deprecated\n */ function router() {\n    return new Router();\n}\n\nfunction mergeRouters(...routerList) {\n    const record = mergeWithoutOverrides({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {\n                throw new Error('You seem to have several error formatters');\n            }\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) {\n                throw new Error('You seem to have several transformers');\n            }\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.some((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.some((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.some((r)=>r._def._config.isServer),\n        $types: routerList[0]?._def._config.$types\n    })(record);\n    return router;\n}\n\n/**\n * TODO: This can be improved:\n * - We should be able to chain `.meta()`/`.context()` only once\n * - Simplify typings\n * - Doesn't need to be a class but it doesn't really hurt either\n */ class TRPCBuilder {\n    context() {\n        return new TRPCBuilder();\n    }\n    meta() {\n        return new TRPCBuilder();\n    }\n    create(options) {\n        return createTRPCInner()(options);\n    }\n}\n/**\n * Initialize tRPC - done exactly once per backend\n */ const initTRPC = new TRPCBuilder();\nfunction createTRPCInner() {\n    return function initTRPCInner(runtime) {\n        const errorFormatter = runtime?.errorFormatter ?? defaultFormatter;\n        const transformer = getDataTransformer$1(runtime?.transformer ?? defaultTransformer);\n        const config = {\n            transformer,\n            isDev: runtime?.isDev ?? globalThis.process?.env?.NODE_ENV !== 'production',\n            allowOutsideOfServer: runtime?.allowOutsideOfServer ?? false,\n            errorFormatter,\n            isServer: runtime?.isServer ?? isServerDefault,\n            /**\n       * @internal\n       */ $types: createFlatProxy((key)=>{\n                throw new Error(`Tried to access \"$types.${key}\" which is not available at runtime`);\n            })\n        };\n        {\n            // Server check\n            const isServer = runtime?.isServer ?? isServerDefault;\n            if (!isServer && runtime?.allowOutsideOfServer !== true) {\n                throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);\n            }\n        }\n        return {\n            /**\n       * These are just types, they can't be used\n       * @internal\n       */ _config: config,\n            /**\n       * Builder object for creating procedures\n       */ procedure: createBuilder({\n                meta: runtime?.defaultMeta\n            }),\n            /**\n       * Create reusable middlewares\n       */ middleware: createMiddlewareFactory(),\n            /**\n       * Create a router\n       */ router: createRouterFactory(config),\n            /**\n       * Merge Routers\n       */ mergeRouters\n        };\n    };\n}\n\nexport { createInputMiddleware, createOutputMiddleware, initTRPC, router };\n", "import { fetchRequestHandler } from '@trpc/server/adapters/fetch'\nimport { initTRPC } from '@trpc/server'\n\nconst t = initTRPC.create()\n\nconst appRouter = t.router({\n    greeting: t.procedure\n        .query(() => 'FROM TRPC')\n})\n\naddEventListener('fetch', (event) => {\n    return event.respondWith(fetchRequestHandler({\n        endpoint: '/trpc',\n        req: event.request,\n        router: appRouter,\n        createContext: () => ({})\n    }))\n})\n"],
  "mappings": ";;;AAAA,WAAS,2BAA2B,KAAK,UAAU;AAC/C,QAAI,OAAO,QAAQ,UAAU;AACzB,aAAO;AAAA,IACX;AACA,QAAI,eAAe,SAAS,OAAO,IAAI,YAAY,UAAU;AACzD,aAAO,IAAI;AAAA,IACf;AACA,WAAO;AAAA,EACX;AACA,WAAS,oBAAoB,OAAO;AAChC,QAAI,iBAAiB,OAAO;AACxB,aAAO;AAAA,IACX;AACA,UAAM,UAAU,2BAA2B,OAAO,eAAe;AACjE,WAAO,IAAI,MAAM,OAAO;AAAA,EAC5B;AACA,WAAS,oBAAoB,OAAO;AAChC,QAAI,iBAAiB,OAAO;AACxB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAEA,WAAS,wBAAwB,OAAO;AACpC,UAAM,QAAQ,oBAAoB,KAAK;AACvC,QAAI,iBAAiB,WAAW;AAC5B,aAAO;AAAA,IACX;AACA,UAAM,YAAY,IAAI,UAAU;AAAA,MAC5B,MAAM;AAAA,MACN,OAAO;AAAA,MACP,SAAS,MAAM;AAAA,IACnB,CAAC;AAED,cAAU,QAAQ,MAAM;AACxB,WAAO;AAAA,EACX;AACA,MAAM,YAAN,cAAwB,MAAM;AAAA,IAC1B,YAAY,MAAK;AACb,YAAM,UAAU,KAAK,WAAW,2BAA2B,KAAK,OAAO,KAAK,IAAI;AAChF,YAAM,QAAQ,KAAK,UAAU,SAAY,oBAAoB,KAAK,KAAK,IAAI;AAG3E,YAAM,SAAS;AAAA,QACX;AAAA,MACJ,CAAC;AACD,WAAK,OAAO,KAAK;AACjB,WAAK,OAAO,KAAK,YAAY;AAAA,IACjC;AAAA,EACJ;;;ACjDA,WAAS,OAAO,KAAK;AACjB,UAAM,SAAS,uBAAO,OAAO,IAAI;AACjC,eAAU,OAAO,KAAI;AACjB,YAAM,IAAI,IAAI,GAAG;AACjB,aAAO,CAAC,IAAI;AAAA,IAChB;AACA,WAAO;AAAA,EACX;AAQI,MAAM,0BAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,IAI9B,aAAa;AAAA;AAAA;AAAA;AAAA,IAGb,aAAa;AAAA;AAAA;AAAA;AAAA,IAGb,uBAAuB;AAAA;AAAA,IAEzB,cAAc;AAAA,IACd,WAAW;AAAA,IACX,WAAW;AAAA,IACX,sBAAsB;AAAA,IACtB,SAAS;AAAA,IACT,UAAU;AAAA,IACV,qBAAqB;AAAA,IACrB,mBAAmB;AAAA,IACnB,mBAAmB;AAAA,IACnB,uBAAuB;AAAA,EAC3B;AACA,MAAM,6BAA6B,OAAO,uBAAuB;;;ACtCjE,MAAM,OAAO,MAAI;AAAA,EAEjB;AACA,WAAS,iBAAiB,UAAU,MAAM;AACtC,UAAM,QAAQ,IAAI,MAAM,MAAM;AAAA,MAC1B,IAAK,MAAM,KAAK;AACZ,YAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ;AAG3C,iBAAO;AAAA,QACX;AACA,eAAO,iBAAiB,UAAU;AAAA,UAC9B,GAAG;AAAA,UACH;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,MACA,MAAO,IAAI,IAAI,MAAM;AACjB,eAAO,SAAS;AAAA,UACZ;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAKI,MAAM,uBAAuB,CAAC,aAAW,iBAAiB,UAAU,CAAC,CAAC;AAKtE,MAAM,kBAAkB,CAAC,aAAW;AACpC,WAAO,IAAI,MAAM,MAAM;AAAA,MACnB,IAAK,MAAM,MAAM;AACb,YAAI,OAAO,SAAS,YAAY,SAAS,QAAQ;AAG7C,iBAAO;AAAA,QACX;AACA,eAAO,SAAS,IAAI;AAAA,MACxB;AAAA,IACJ,CAAC;AAAA,EACL;;;ACrCI,WAAS,mBAAmB,aAAa;AACzC,QAAI,WAAW,aAAa;AACxB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,MACH,OAAO;AAAA,MACP,QAAQ;AAAA,IACZ;AAAA,EACJ;AAGI,MAAM,qBAAqB;AAAA,IAC3B,UAAU;AAAA,IACV,OAAO;AAAA,MACH,WAAW,CAAC,QAAM;AAAA,MAClB,aAAa,CAAC,QAAM;AAAA,IACxB;AAAA,IACA,QAAQ;AAAA,MACJ,WAAW,CAAC,QAAM;AAAA,MAClB,aAAa,CAAC,QAAM;AAAA,IACxB;AAAA,EACJ;AAEA,MAAM,mBAAmB,CAAC,EAAE,MAAO,MAAI;AACnC,WAAO;AAAA,EACX;AAEA,MAAMA,8BAA6B,OAAO,uBAAuB;AACjE,MAAM,wBAAwB;AAAA,IAC1B,aAAa;AAAA,IACb,aAAa;AAAA,IACb,WAAW;AAAA,IACX,uBAAuB;AAAA,IACvB,cAAc;AAAA,IACd,WAAW;AAAA,IACX,SAAS;AAAA,IACT,UAAU;AAAA,IACV,uBAAuB;AAAA,IACvB,qBAAqB;AAAA,IACrB,mBAAmB;AAAA,IACnB,sBAAsB;AAAA,IACtB,mBAAmB;AAAA,EACvB;AACA,WAAS,qBAAqB,MAAM;AAChC,WAAO,sBAAsB,IAAI,KAAK;AAAA,EAC1C;AACA,WAAS,kBAAkB,MAAM;AAC7B,UAAM,MAAM,MAAM,QAAQ,IAAI,IAAI,OAAO;AAAA,MACrC;AAAA,IACJ;AACA,UAAM,eAAe,IAAI,IAAI,IAAI,IAAI,CAAC,QAAM;AACxC,UAAI,WAAW,KAAK;AAChB,cAAM,OAAO,IAAI,MAAM;AACvB,YAAI,OAAO,KAAK,eAAe,UAAU;AACrC,iBAAO,KAAK;AAAA,QAChB;AACA,cAAM,OAAOA,4BAA2B,IAAI,MAAM,IAAI;AACtD,eAAO,qBAAqB,IAAI;AAAA,MACpC;AACA,aAAO;AAAA,IACX,CAAC,CAAC;AACF,QAAI,aAAa,SAAS,GAAG;AACzB,aAAO;AAAA,IACX;AACA,UAAM,aAAa,aAAa,OAAO,EAAE,KAAK,EAAE;AAChD,WAAO;AAAA,EACX;AACA,WAAS,2BAA2B,OAAO;AACvC,UAAM,EAAE,KAAM,IAAI;AAClB,WAAO,qBAAqB,IAAI;AAAA,EACpC;AAKI,WAAS,cAAc,KAAK;AAC5B,WAAO,OAAO,OAAO,uBAAO,OAAO,IAAI,GAAG,GAAG;AAAA,EACjD;AAEA,MAAM,iBAAiB;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAEA,WAAS,SAAS,mBAAmB;AACjC,WAAO,YAAY,kBAAkB;AAAA,EACzC;AACA,WAAS,eAAe,mBAAmB;AACvC,WAAO,EAAE,UAAU;AAAA,EACvB;AACA,MAAM,cAAc;AAAA,IAChB,MAAM;AAAA,IACN,aAAa;AAAA,IACb,OAAO;AAAA,IACP,SAAS,CAAC;AAAA,IACV,WAAW,CAAC;AAAA,IACZ,eAAe,CAAC;AAAA,IAChB,gBAAgB;AAAA,IAChB,aAAa;AAAA,EACjB;AAGI,MAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA,IAIpB;AAAA;AAAA;AAAA;AAAA,IAGA;AAAA,EACN;AAGI,WAAS,oBAAoB,QAAQ;AACrC,WAAO,SAAS,kBAAkB,YAAY;AAC1C,YAAM,oBAAoB,IAAI,IAAI,OAAO,KAAK,UAAU,EAAE,OAAO,CAAC,MAAI,cAAc,SAAS,CAAC,CAAC,CAAC;AAChG,UAAI,kBAAkB,OAAO,GAAG;AAC5B,cAAM,IAAI,MAAM,+CAA+C,MAAM,KAAK,iBAAiB,EAAE,KAAK,IAAI,CAAC;AAAA,MAC3G;AACA,YAAM,gBAAgB,CAAC;AACvB,iBAAW,CAAC,KAAK,iBAAiB,KAAK,OAAO,QAAQ,cAAc,CAAC,CAAC,GAAE;AACpE,cAAM,QAAQ,WAAW,GAAG,KAAK,CAAC;AAClC,YAAI,eAAe,KAAK,GAAG;AACvB,wBAAc,GAAG,IAAI,kBAAkB,KAAK;AAC5C;AAAA,QACJ;AACA,YAAI,SAAS,KAAK,GAAG;AACjB,wBAAc,GAAG,IAAI;AACrB;AAAA,QACJ;AACA,sBAAc,GAAG,IAAI;AAAA,MACzB;AACA,YAAM,mBAAmB,cAAc,CAAC,CAAC;AACzC,eAAS,kBAAkBC,aAAY,OAAO,IAAI;AAC9C,mBAAW,CAAC,KAAK,iBAAiB,KAAK,OAAO,QAAQA,eAAc,CAAC,CAAC,GAAE;AACpE,gBAAM,UAAU,GAAG,OAAO;AAC1B,cAAI,eAAe,iBAAiB,GAAG;AACnC,8BAAkB,mBAAmB,GAAG,UAAU;AAClD;AAAA,UACJ;AACA,cAAI,SAAS,iBAAiB,GAAG;AAC7B,8BAAkB,kBAAkB,KAAK,YAAY,GAAG,UAAU;AAClE;AAAA,UACJ;AACA,cAAI,iBAAiB,OAAO,GAAG;AAC3B,kBAAM,IAAI,MAAM,kBAAkB,SAAS;AAAA,UAC/C;AACA,2BAAiB,OAAO,IAAI;AAAA,QAChC;AAAA,MACJ;AACA,wBAAkB,aAAa;AAC/B,YAAM,OAAO;AAAA,QACT,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,YAAY;AAAA,QACZ,GAAG;AAAA,QACH,QAAQ;AAAA,QACR,SAAS,OAAO,QAAQ,gBAAgB,EAAE,OAAO,CAAC,SAAO,KAAK,CAAC,EAAE,KAAK,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,OAAK;AAAA,UAChG,GAAG;AAAA,UACH,CAAC,GAAG,GAAG;AAAA,QACX,IAAI,CAAC,CAAC;AAAA,QACV,WAAW,OAAO,QAAQ,gBAAgB,EAAE,OAAO,CAAC,SAAO,KAAK,CAAC,EAAE,KAAK,QAAQ,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,OAAK;AAAA,UACrG,GAAG;AAAA,UACH,CAAC,GAAG,GAAG;AAAA,QACX,IAAI,CAAC,CAAC;AAAA,QACV,eAAe,OAAO,QAAQ,gBAAgB,EAAE,OAAO,CAAC,SAAO,KAAK,CAAC,EAAE,KAAK,YAAY,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,OAAK;AAAA,UAC7G,GAAG;AAAA,UACH,CAAC,GAAG,GAAG;AAAA,QACX,IAAI,CAAC,CAAC;AAAA,MACd;AACA,YAAM,SAAS;AAAA,QACX,GAAG;AAAA,QACH;AAAA,QACA,aAAc,KAAK;AACf,gBAAM,QAAQ,qBAAqB,CAAC,EAAE,MAAO,KAAM,MAAI;AAEnD,gBAAI,KAAK,WAAW,KAAK,eAAe,SAAS,KAAK,CAAC,CAAC,GAAG;AACvD,qBAAO,cAAc;AAAA,gBACjB,YAAY,KAAK;AAAA,gBACjB,MAAM,KAAK,CAAC;AAAA,gBACZ,UAAU,KAAK,CAAC;AAAA,gBAChB;AAAA,gBACA,MAAM,KAAK,CAAC;AAAA,cAChB,CAAC;AAAA,YACL;AACA,kBAAM,WAAW,KAAK,KAAK,GAAG;AAC9B,kBAAM,YAAY,KAAK,WAAW,QAAQ;AAC1C,gBAAI,OAAO;AACX,gBAAI,UAAU,KAAK,UAAU;AACzB,qBAAO;AAAA,YACX,WAAW,UAAU,KAAK,cAAc;AACpC,qBAAO;AAAA,YACX;AACA,mBAAO,UAAU;AAAA,cACb,MAAM;AAAA,cACN,UAAU,KAAK,CAAC;AAAA,cAChB;AAAA,cACA;AAAA,YACJ,CAAC;AAAA,UACL,CAAC;AACD,iBAAO;AAAA,QACX;AAAA,QACA,cAAe,MAAM;AACjB,gBAAM,EAAE,MAAO,MAAO,IAAI;AAC1B,gBAAM,EAAE,KAAM,IAAI,KAAK;AACvB,gBAAM,QAAQ;AAAA,YACV,SAAS,MAAM;AAAA,YACf,MAAM,wBAAwB,IAAI;AAAA,YAClC,MAAM;AAAA,cACF;AAAA,cACA,YAAY,2BAA2B,KAAK;AAAA,YAChD;AAAA,UACJ;AACA,cAAI,OAAO,SAAS,OAAO,KAAK,MAAM,UAAU,UAAU;AACtD,kBAAM,KAAK,QAAQ,KAAK,MAAM;AAAA,UAClC;AACA,cAAI,OAAO,SAAS,UAAU;AAC1B,kBAAM,KAAK,OAAO;AAAA,UACtB;AACA,iBAAO,KAAK,KAAK,QAAQ,eAAe;AAAA,YACpC,GAAG;AAAA,YACH;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAGI,WAAS,cAAc,MAAM;AAC7B,UAAM,EAAE,MAAO,KAAM,IAAI;AACzB,QAAI,EAAE,QAAQ,KAAK,eAAe,CAAC,KAAK,WAAW,IAAI,GAAG,KAAK,IAAI,GAAG;AAClE,YAAM,IAAI,UAAU;AAAA,QAChB,MAAM;AAAA,QACN,SAAS,OAAO,4BAA4B;AAAA,MAChD,CAAC;AAAA,IACL;AACA,UAAM,YAAY,KAAK,WAAW,IAAI;AACtC,WAAO,UAAU,IAAI;AAAA,EACzB;AAII,MAAM,kBAAkB,OAAO,WAAW,eAAe,UAAU,UAAU,WAAW,SAAS,KAAK,aAAa,UAAU,CAAC,CAAC,WAAW,SAAS,KAAK,kBAAkB,CAAC,CAAC,WAAW,SAAS,KAAK;;;AC7PzM,WAAS,0BAA0B,QAAQ,MAAM;AAC7C,QAAI,WAAW,MAAM;AACjB,aAAO;AAAA,QACH,GAAG;AAAA,QACH,OAAO,OAAO,KAAK,QAAQ,YAAY,OAAO,UAAU,KAAK,KAAK;AAAA,MACtE;AAAA,IACJ;AACA,QAAI,UAAU,KAAK,QAAQ;AACvB,aAAO;AAAA,QACH,GAAG;AAAA,QACH,QAAQ;AAAA,UACJ,GAAG,KAAK;AAAA,UACR,MAAM,OAAO,KAAK,QAAQ,YAAY,OAAO,UAAU,KAAK,OAAO,IAAI;AAAA,QAC3E;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAGK,WAAS,sBAAsB,QAAQ,aAAa;AACrD,WAAO,MAAM,QAAQ,WAAW,IAAI,YAAY,IAAI,CAAC,SAAO,0BAA0B,QAAQ,IAAI,CAAC,IAAI,0BAA0B,QAAQ,WAAW;AAAA,EACxJ;;;AClBA,MAAM,iCAAiC;AAAA,IACnC,KAAK;AAAA,IACL,MAAM;AAAA,EACV;AACA,WAAS,4BAA4B,KAAK;AACtC,QAAI;AACA,UAAI,IAAI,WAAW,OAAO;AACtB,YAAI,CAAC,IAAI,MAAM,IAAI,OAAO,GAAG;AACzB,iBAAO;AAAA,QACX;AACA,cAAM,MAAM,IAAI,MAAM,IAAI,OAAO;AACjC,eAAO,KAAK,MAAM,GAAG;AAAA,MACzB;AACA,UAAI,OAAO,IAAI,SAAS,UAAU;AAE9B,eAAO,IAAI,KAAK,WAAW,IAAI,SAAY,KAAK,MAAM,IAAI,IAAI;AAAA,MAClE;AACA,aAAO,IAAI;AAAA,IACf,SAAS,KAAP;AACE,YAAM,IAAI,UAAU;AAAA,QAChB,MAAM;AAAA,QACN,OAAO,oBAAoB,GAAG;AAAA,MAClC,CAAC;AAAA,IACL;AAAA,EACJ;AACA,iBAAe,oBAAoB,MAAM;AACrC,UAAM,EAAE,eAAgB,SAAU,QAAS,IAAK,IAAI;AACpD,UAAM,kBAAkB,KAAK,UAAU,WAAW;AAClD,QAAI,IAAI,WAAW,QAAQ;AAEvB,aAAO;AAAA,QACH,QAAQ;AAAA,MACZ;AAAA,IACJ;AACA,UAAM,OAAO,+BAA+B,IAAI,MAAM,KAAK;AAC3D,QAAI,MAAM;AACV,QAAI,QAAQ;AACZ,UAAM,cAAc,CAAC,CAAC,IAAI,MAAM,IAAI,OAAO;AAC3C,aAAS,YAAY,mBAAmB,QAAQ;AAC5C,UAAI,SAAS,kBAAkB,iBAAiB;AAChD,YAAM,UAAU;AAAA,QACZ,gBAAgB;AAAA,MACpB;AACA,YAAM,OAAO,KAAK,eAAe;AAAA,QAC7B;AAAA,QACA;AAAA,QACA;AAAA,QACA,MAAM,MAAM,QAAQ,iBAAiB,IAAI,oBAAoB;AAAA,UACzD;AAAA,QACJ;AAAA,QACA;AAAA,MACJ,CAAC,KAAK,CAAC;AACP,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,WAAW,CAAC,CAAC,GAAE;AAC1D,gBAAQ,GAAG,IAAI;AAAA,MACnB;AACA,UAAI,KAAK,QAAQ;AACb,iBAAS,KAAK;AAAA,MAClB;AACA,YAAM,kBAAkB,sBAAsB,QAAQ,iBAAiB;AACvE,YAAM,OAAO,KAAK,UAAU,eAAe;AAC3C,aAAO;AAAA,QACH;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,QAAI;AACA,UAAI,KAAK,OAAO;AACZ,cAAM,KAAK;AAAA,MACf;AACA,UAAI,eAAe,CAAC,iBAAiB;AACjC,cAAM,IAAI,MAAM,uCAAuC;AAAA,MAC3D;AACsC,UAAI,SAAS,gBAAgB;AAC/D,cAAM,IAAI,UAAU;AAAA,UAChB,SAAS;AAAA,UACT,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AACA,UAAI,SAAS,WAAW;AACpB,cAAM,IAAI,UAAU;AAAA,UAChB,SAAS,6BAA6B,IAAI;AAAA,UAC1C,MAAM;AAAA,QACV,CAAC;AAAA,MACL;AACA,YAAM,WAAW,4BAA4B,GAAG;AAChD,cAAQ,cAAc,KAAK,KAAK,MAAM,GAAG,IAAI;AAAA,QACzC,KAAK;AAAA,MACT;AACA,YAAM,MAAM,cAAc;AAC1B,YAAM,wBAAwB,CAAC,aAAW;AACtC,eAAO,OAAO,aAAa,cAAc,OAAO,KAAK,QAAQ,YAAY,MAAM,YAAY,QAAQ,IAAI;AAAA,MAC3G;AACA,YAAM,YAAY,MAAI;AAClB,YAAI,CAAC,aAAa;AACd,iBAAO;AAAA,YACH,GAAG,sBAAsB,QAAQ;AAAA,UACrC;AAAA,QACJ;AACsC,YAAI,YAAY,QAAQ,OAAO,aAAa,YAAY,MAAM,QAAQ,QAAQ,GAAG;AACnH,gBAAM,IAAI,UAAU;AAAA,YAChB,MAAM;AAAA,YACN,SAAS;AAAA,UACb,CAAC;AAAA,QACL;AACA,cAAM,QAAQ,CAAC;AACf,mBAAU,OAAO,UAAS;AACtB,gBAAM,IAAI;AACV,gBAAM,WAAW,SAAS,CAAC;AAC3B,gBAAM,QAAQ,sBAAsB,QAAQ;AAC5C,gBAAM,CAAC,IAAI;AAAA,QACf;AACA,eAAO;AAAA,MACX;AACA,YAAM,SAAS,UAAU;AACzB,YAAM,aAAa,MAAM,QAAQ,IAAI,MAAM,IAAI,OAAO,MAAM,UAAQ;AAChE,cAAM,QAAQ,OAAO,KAAK;AAC1B,YAAI;AACA,gBAAM,SAAS,MAAM,cAAc;AAAA,YAC/B,YAAY,OAAO,KAAK;AAAA,YACxB;AAAA,YACA,UAAU;AAAA,YACV;AAAA,YACA;AAAA,UACJ,CAAC;AACD,iBAAO;AAAA,YACH;AAAA,YACA;AAAA,YACA,MAAM;AAAA,UACV;AAAA,QACJ,SAAS,OAAP;AACE,gBAAM,QAAQ,wBAAwB,KAAK;AAC3C,oBAAU;AAAA,YACN;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACJ,CAAC;AACD,iBAAO;AAAA,YACH;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC,CAAC;AACF,YAAM,SAAS,WAAW,QAAQ,CAAC,QAAM,IAAI,QAAQ;AAAA,QAC7C,IAAI;AAAA,MACR,IAAI,CAAC,CAAC;AACV,YAAM,kBAAkB,WAAW,IAAI,CAAC,QAAM;AAC1C,cAAM,EAAE,MAAO,MAAO,IAAI;AAC1B,YAAI,IAAI,OAAO;AACX,iBAAO;AAAA,YACH,OAAO,OAAO,cAAc;AAAA,cACxB,OAAO,IAAI;AAAA,cACX;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACJ,CAAC;AAAA,UACL;AAAA,QACJ,OAAO;AACH,iBAAO;AAAA,YACH,QAAQ;AAAA,cACJ,MAAM,IAAI;AAAA,YACd;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AACD,YAAM,SAAS,cAAc,kBAAkB,gBAAgB,CAAC;AAChE,aAAO,YAAY,QAAQ,MAAM;AAAA,IACrC,SAAS,OAAP;AAOE,YAAM,QAAQ,wBAAwB,KAAK;AAC3C,gBAAU;AAAA,QACN;AAAA,QACA,MAAM;AAAA,QACN,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,MACJ,CAAC;AACD,aAAO,YAAY;AAAA,QACf,OAAO,OAAO,cAAc;AAAA,UACxB;AAAA,UACA;AAAA,UACA,MAAM;AAAA,UACN,OAAO;AAAA,UACP;AAAA,QACJ,CAAC;AAAA,MACL,GAAG;AAAA,QACC;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;;;ACrMA,iBAAe,oBAAoB,MAAM;AACrC,UAAM,aAAa,IAAI,QAAQ;AAC/B,UAAM,gBAAgB,YAAU;AAC5B,aAAO,KAAK,gBAAgB;AAAA,QACxB,KAAK,KAAK;AAAA,QACV;AAAA,MACJ,CAAC;AAAA,IACL;AACA,UAAM,MAAM,IAAI,IAAI,KAAK,IAAI,GAAG;AAChC,UAAM,OAAO,IAAI,SAAS,MAAM,KAAK,SAAS,SAAS,CAAC;AACxD,UAAM,MAAM;AAAA,MACR,OAAO,IAAI;AAAA,MACX,QAAQ,KAAK,IAAI;AAAA,MACjB,SAAS,OAAO,YAAY,KAAK,IAAI,OAAO;AAAA,MAC5C,MAAM,MAAM,KAAK,IAAI,KAAK;AAAA,IAC9B;AACA,UAAM,SAAS,MAAM,oBAAoB;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ,KAAK;AAAA,MACb,UAAU,KAAK;AAAA,MACf,cAAc,KAAK;AAAA,MACnB,QAAS,GAAG;AACR,cAAM,UAAU;AAAA,UACZ,GAAG;AAAA,UACH,KAAK,KAAK;AAAA,QACd,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AACD,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,OAAO,WAAW,CAAC,CAAC,GAAE;AACtB,UAAI,OAAO,UAAU,aAAa;AACpE;AAAA,MACJ;AACA,UAAI,OAAO,UAAU,UAAU;AAC3B,mBAAW,IAAI,KAAK,KAAK;AACzB;AAAA,MACJ;AACA,iBAAW,KAAK,OAAM;AAClB,mBAAW,OAAO,KAAK,CAAC;AAAA,MAC5B;AAAA,IACJ;AACA,UAAM,MAAM,IAAI,SAAS,OAAO,MAAM;AAAA,MAClC,QAAQ,OAAO;AAAA,MACf,SAAS;AAAA,IACb,CAAC;AACD,WAAO;AAAA,EACX;;;ACgIA,WAAS,WAAW,iBAAiB;AACjC,UAAM,SAAS;AACf,QAAI,OAAO,WAAW,YAAY;AAE9B,aAAO;AAAA,IACX;AACA,QAAI,OAAO,OAAO,eAAe,YAAY;AAEzC,aAAO,OAAO,WAAW,KAAK,MAAM;AAAA,IACxC;AACA,QAAI,OAAO,OAAO,UAAU,YAAY;AAEpC,aAAO,OAAO,MAAM,KAAK,MAAM;AAAA,IACnC;AACA,QAAI,OAAO,OAAO,iBAAiB,YAAY;AAE3C,aAAO,OAAO,aAAa,KAAK,MAAM;AAAA,IAC1C;AACA,QAAI,OAAO,OAAO,WAAW,YAAY;AAErC,aAAO,OAAO,OAAO,KAAK,MAAM;AAAA,IACpC;AACA,QAAI,OAAO,OAAO,WAAW,YAAY;AAErC,aAAO,CAAC,UAAQ;AACZ,eAAO,OAAO,KAAK;AACnB,eAAO;AAAA,MACX;AAAA,IACJ;AACA,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACnD;AAaI,WAAS,sBAAsB,SAAS,MAAM;AAC9C,UAAM,SAAS,OAAO,OAAO,uBAAO,OAAO,IAAI,GAAG,IAAI;AACtD,eAAW,aAAa,MAAK;AACzB,iBAAU,OAAO,WAAU;AACvB,YAAI,OAAO,UAAU,OAAO,GAAG,MAAM,UAAU,GAAG,GAAG;AACjD,gBAAM,IAAI,MAAM,iBAAiB,KAAK;AAAA,QAC1C;AACA,eAAO,GAAG,IAAI,UAAU,GAAG;AAAA,MAC/B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAII,WAAS,0BAA0B;AACnC,aAAS,sBAAsB,aAAa;AACxC,aAAO;AAAA,QACH,cAAc;AAAA,QACd,cAAe,uBAAuB;AAClC,gBAAM,kBAAkB,kBAAkB,wBAAwB,sBAAsB,eAAe;AAAA,YACnG;AAAA,UACJ;AACA,iBAAO,sBAAsB;AAAA,YACzB,GAAG;AAAA,YACH,GAAG;AAAA,UACP,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AACA,aAAS,iBAAiB,IAAI;AAC1B,aAAO,sBAAsB;AAAA,QACzB;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AACA,WAAS,cAAc,KAAK;AACxB,WAAO,OAAO,OAAO,QAAQ,YAAY,CAAC,MAAM,QAAQ,GAAG;AAAA,EAC/D;AAII,WAAS,sBAAsB,OAAO;AACtC,UAAM,kBAAkB,OAAO,EAAE,MAAO,UAAW,MAAO,MAAI;AAC1D,UAAI;AACJ,UAAI;AACA,sBAAc,MAAM,MAAM,QAAQ;AAAA,MACtC,SAAS,OAAP;AACE,cAAM,IAAI,UAAU;AAAA,UAChB,MAAM;AAAA,UACN,OAAO,oBAAoB,KAAK;AAAA,QACpC,CAAC;AAAA,MACL;AAEA,YAAM,gBAAgB,cAAc,KAAK,KAAK,cAAc,WAAW,IAAI;AAAA,QACvE,GAAG;AAAA,QACH,GAAG;AAAA,MACP,IAAI;AAEJ,aAAO,KAAK;AAAA,QACR,OAAO;AAAA,MACX,CAAC;AAAA,IACL;AACA,oBAAgB,QAAQ;AACxB,WAAO;AAAA,EACX;AAGI,WAAS,uBAAuB,OAAO;AACvC,UAAM,mBAAmB,OAAO,EAAE,KAAM,MAAI;AACxC,YAAM,SAAS,MAAM,KAAK;AAC1B,UAAI,CAAC,OAAO,IAAI;AAEZ,eAAO;AAAA,MACX;AACA,UAAI;AACA,cAAM,OAAO,MAAM,MAAM,OAAO,IAAI;AACpC,eAAO;AAAA,UACH,GAAG;AAAA,UACH;AAAA,QACJ;AAAA,MACJ,SAAS,OAAP;AACE,cAAM,IAAI,UAAU;AAAA,UAChB,SAAS;AAAA,UACT,MAAM;AAAA,UACN,OAAO,oBAAoB,KAAK;AAAA,QACpC,CAAC;AAAA,MACL;AAAA,IACJ;AACA,qBAAiB,QAAQ;AACzB,WAAO;AAAA,EACX;AAII,MAAM,mBAAmB;AAE7B,WAAS,iBAAiB,MAAM,MAAM;AAClC,UAAM,EAAE,cAAa,CAAC,GAAI,QAAS,MAAO,GAAG,KAAK,IAAI;AAEtD,WAAO,cAAc;AAAA,MACjB,GAAG,sBAAsB,MAAM,IAAI;AAAA,MACnC,QAAQ;AAAA,QACJ,GAAG,KAAK;AAAA,QACR,GAAG,UAAU,CAAC;AAAA,MAClB;AAAA,MACA,aAAa;AAAA,QACT,GAAG,KAAK;AAAA,QACR,GAAG;AAAA,MACP;AAAA,MACA,MAAM,KAAK,QAAQ,OAAO;AAAA,QACtB,GAAG,KAAK;AAAA,QACR,GAAG;AAAA,MACP,IAAI,QAAQ,KAAK;AAAA,IACrB,CAAC;AAAA,EACL;AACA,WAAS,cAAc,UAAU,CAAC,GAAG;AACjC,UAAM,OAAO;AAAA,MACT,QAAQ,CAAC;AAAA,MACT,aAAa,CAAC;AAAA,MACd,GAAG;AAAA,IACP;AACA,WAAO;AAAA,MACH;AAAA,MACA,MAAO,OAAO;AACV,cAAM,SAAS,WAAW,KAAK;AAC/B,eAAO,iBAAiB,MAAM;AAAA,UAC1B,QAAQ;AAAA,YACJ;AAAA,UACJ;AAAA,UACA,aAAa;AAAA,YACT,sBAAsB,MAAM;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,MACA,OAAQ,QAAQ;AACZ,cAAM,cAAc,WAAW,MAAM;AACrC,eAAO,iBAAiB,MAAM;AAAA,UAC1B;AAAA,UACA,aAAa;AAAA,YACT,uBAAuB,WAAW;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,MACA,KAAM,MAAM;AACR,eAAO,iBAAiB,MAAM;AAAA,UAC1B;AAAA,QACJ,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA;AAAA,MAIA,gBAAiB,SAAS;AACtB,eAAO,iBAAiB,MAAM,QAAQ,IAAI;AAAA,MAC9C;AAAA,MACA,IAAK,uBAAuB;AAExB,cAAM,cAAc,kBAAkB,wBAAwB,sBAAsB,eAAe;AAAA,UAC/F;AAAA,QACJ;AACA,eAAO,iBAAiB,MAAM;AAAA,UAC1B;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,MACA,MAAO,UAAU;AACb,eAAO,eAAe;AAAA,UAClB,GAAG;AAAA,UACH,OAAO;AAAA,QACX,GAAG,QAAQ;AAAA,MACf;AAAA,MACA,SAAU,UAAU;AAChB,eAAO,eAAe;AAAA,UAClB,GAAG;AAAA,UACH,UAAU;AAAA,QACd,GAAG,QAAQ;AAAA,MACf;AAAA,MACA,aAAc,UAAU;AACpB,eAAO,eAAe;AAAA,UAClB,GAAG;AAAA,UACH,cAAc;AAAA,QAClB,GAAG,QAAQ;AAAA,MACf;AAAA,IACJ;AAAA,EACJ;AACA,WAAS,eAAe,MAAM,UAAU;AACpC,UAAM,eAAe,iBAAiB,MAAM;AAAA,MACxC;AAAA,MACA,aAAa;AAAA,QACT,eAAe,kBAAkB,MAAM;AACnC,gBAAM,OAAO,MAAM,SAAS,IAAI;AAChC,iBAAO;AAAA,YACH,QAAQ;AAAA,YACR,IAAI;AAAA,YACJ;AAAA,YACA,KAAK,KAAK;AAAA,UACd;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AACD,WAAO,sBAAsB,aAAa,IAAI;AAAA,EAClD;AACA,MAAM,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAShB,KAAK;AACP,WAAS,sBAAsB,MAAM;AACjC,UAAM,YAAY,eAAe,QAAQ,MAAM;AAE3C,UAAI,CAAC,QAAQ,EAAE,cAAc,OAAO;AAChC,cAAM,IAAI,MAAM,SAAS;AAAA,MAC7B;AAEA,YAAM,gBAAgB,OAAO,WAAW;AAAA,QACpC,OAAO;AAAA,QACP,KAAK,KAAK;AAAA,MACd,MAAI;AACA,YAAI;AAEA,gBAAM,aAAa,KAAK,YAAY,SAAS,KAAK;AAClD,gBAAMC,UAAS,MAAM,WAAW;AAAA,YAC5B,KAAK,SAAS;AAAA,YACd,MAAM,KAAK;AAAA,YACX,MAAM,KAAK;AAAA,YACX,UAAU,KAAK;AAAA,YACf,MAAM,KAAK;AAAA,YACX,OAAO,SAAS;AAAA,YAChB,MAAM,OAAO,aAAW;AACpB,qBAAO,MAAM,cAAc;AAAA,gBACvB,OAAO,SAAS,QAAQ;AAAA,gBACxB,KAAK,YAAY,SAAS,WAAW;AAAA,kBACjC,GAAG,SAAS;AAAA,kBACZ,GAAG,SAAS;AAAA,gBAChB,IAAI,SAAS;AAAA,gBACb,OAAO,YAAY,WAAW,WAAW,SAAS,QAAQ,SAAS;AAAA,cACvE,CAAC;AAAA,YACL;AAAA,UACJ,CAAC;AACD,iBAAOA;AAAA,QACX,SAAS,OAAP;AACE,iBAAO;AAAA,YACH,IAAI;AAAA,YACJ,OAAO,wBAAwB,KAAK;AAAA,YACpC,QAAQ;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,SAAS,MAAM,cAAc;AACnC,UAAI,CAAC,QAAQ;AACT,cAAM,IAAI,UAAU;AAAA,UAChB,MAAM;AAAA,UACN,SAAS;AAAA,QACb,CAAC;AAAA,MACL;AACA,UAAI,CAAC,OAAO,IAAI;AAEZ,cAAM,OAAO;AAAA,MACjB;AACA,aAAO,OAAO;AAAA,IAClB;AACA,cAAU,OAAO;AACjB,cAAU,OAAO,KAAK;AACtB,WAAO;AAAA,EACX;AA8QA,WAAS,gBAAgB,YAAY;AACjC,UAAM,SAAS,sBAAsB,CAAC,GAAG,GAAG,WAAW,IAAI,CAAC,MAAI,EAAE,KAAK,MAAM,CAAC;AAC9E,UAAM,iBAAiB,WAAW,OAAO,CAAC,uBAAuB,eAAa;AAC1E,UAAI,WAAW,KAAK,QAAQ,kBAAkB,WAAW,KAAK,QAAQ,mBAAmB,kBAAkB;AACvG,YAAI,0BAA0B,oBAAoB,0BAA0B,WAAW,KAAK,QAAQ,gBAAgB;AAChH,gBAAM,IAAI,MAAM,2CAA2C;AAAA,QAC/D;AACA,eAAO,WAAW,KAAK,QAAQ;AAAA,MACnC;AACA,aAAO;AAAA,IACX,GAAG,gBAAgB;AACnB,UAAM,cAAc,WAAW,OAAO,CAAC,MAAM,YAAU;AACnD,UAAI,QAAQ,KAAK,QAAQ,eAAe,QAAQ,KAAK,QAAQ,gBAAgB,oBAAoB;AAC7F,YAAI,SAAS,sBAAsB,SAAS,QAAQ,KAAK,QAAQ,aAAa;AAC1E,gBAAM,IAAI,MAAM,uCAAuC;AAAA,QAC3D;AACA,eAAO,QAAQ,KAAK,QAAQ;AAAA,MAChC;AACA,aAAO;AAAA,IACX,GAAG,kBAAkB;AACrB,UAAM,SAAS,oBAAoB;AAAA,MAC/B;AAAA,MACA;AAAA,MACA,OAAO,WAAW,KAAK,CAAC,MAAI,EAAE,KAAK,QAAQ,KAAK;AAAA,MAChD,sBAAsB,WAAW,KAAK,CAAC,MAAI,EAAE,KAAK,QAAQ,oBAAoB;AAAA,MAC9E,UAAU,WAAW,KAAK,CAAC,MAAI,EAAE,KAAK,QAAQ,QAAQ;AAAA,MACtD,QAAQ,WAAW,CAAC,GAAG,KAAK,QAAQ;AAAA,IACxC,CAAC,EAAE,MAAM;AACT,WAAO;AAAA,EACX;AAOI,MAAM,cAAN,MAAkB;AAAA,IAClB,UAAU;AACN,aAAO,IAAI,YAAY;AAAA,IAC3B;AAAA,IACA,OAAO;AACH,aAAO,IAAI,YAAY;AAAA,IAC3B;AAAA,IACA,OAAO,SAAS;AACZ,aAAO,gBAAgB,EAAE,OAAO;AAAA,IACpC;AAAA,EACJ;AAGI,MAAM,WAAW,IAAI,YAAY;AACrC,WAAS,kBAAkB;AACvB,WAAO,SAAS,cAAc,SAAS;AACnC,YAAM,iBAAiB,SAAS,kBAAkB;AAClD,YAAM,cAAc,mBAAqB,SAAS,eAAe,kBAAkB;AACnF,YAAM,SAAS;AAAA,QACX;AAAA,QACA,OAAO,SAAS,SAAS,WAAW,SAAS,KAAK,aAAa;AAAA,QAC/D,sBAAsB,SAAS,wBAAwB;AAAA,QACvD;AAAA,QACA,UAAU,SAAS,YAAY;AAAA;AAAA;AAAA;AAAA,QAGjC,QAAQ,gBAAgB,CAAC,QAAM;AACzB,gBAAM,IAAI,MAAM,2BAA2B,wCAAwC;AAAA,QACvF,CAAC;AAAA,MACL;AACA;AAEI,cAAM,WAAW,SAAS,YAAY;AACtC,YAAI,CAAC,YAAY,SAAS,yBAAyB,MAAM;AACrD,gBAAM,IAAI,MAAM,kGAAkG;AAAA,QACtH;AAAA,MACJ;AACA,aAAO;AAAA;AAAA;AAAA;AAAA;AAAA,QAIL,SAAS;AAAA;AAAA;AAAA;AAAA,QAGT,WAAW,cAAc;AAAA,UACnB,MAAM,SAAS;AAAA,QACnB,CAAC;AAAA;AAAA;AAAA;AAAA,QAGH,YAAY,wBAAwB;AAAA;AAAA;AAAA;AAAA,QAGpC,QAAQ,oBAAoB,MAAM;AAAA;AAAA;AAAA;AAAA,QAGlC;AAAA,MACF;AAAA,IACJ;AAAA,EACJ;;;ACx1BA,MAAM,IAAI,SAAS,OAAO;AAE1B,MAAM,YAAY,EAAE,OAAO;AAAA,IACvB,UAAU,EAAE,UACP,MAAM,MAAM,WAAW;AAAA,EAChC,CAAC;AAED,mBAAiB,SAAS,CAAC,UAAU;AACjC,WAAO,MAAM,YAAY,oBAAoB;AAAA,MACzC,UAAU;AAAA,MACV,KAAK,MAAM;AAAA,MACX,QAAQ;AAAA,MACR,eAAe,OAAO,CAAC;AAAA,IAC3B,CAAC,CAAC;AAAA,EACN,CAAC;",
  "names": ["TRPC_ERROR_CODES_BY_NUMBER", "procedures", "result"]
}
